/**
 * Booking Service - Type-safe database operations for bookings
 */

import { supabase } from '@/integrations/supabase/client';
import type { Database } from '@/integrations/supabase/types';

// Type aliases from Supabase generated types
type Booking = Database['public']['Tables']['bookings']['Row'];
type BookingInsert = Database['public']['Tables']['bookings']['Insert'];
type BookingUpdate = Database['public']['Tables']['bookings']['Update'];
type BookingStatus = Database['public']['Enums']['booking_status_enum'];

// Type for creating a new booking (simplified from Insert type)
export interface CreateBookingInput {
  customer_id: string;
  pickup_address: string;
  pickup_latitude: number;
  pickup_longitude: number;
  dropoff_address: string;
  dropoff_latitude: number;
  dropoff_longitude: number;
  scheduled_date: string;
  scheduled_time_start: string;
  scheduled_time_end?: string;
  property_size: string;
  estimated_price: number;
  special_instructions?: string;
  customer_notes?: string;
  quote_id?: string;
  inventory?: any;
  additional_services?: string[];
  has_fragile_items?: boolean;
  requires_insurance?: boolean;
}

// Type for updating a booking (simplified from Update type)
export interface UpdateBookingInput {
  status?: BookingStatus;
  mover_id?: string;
  quoted_price?: number;
  final_price?: number;
  mover_notes?: string;
  admin_notes?: string;
}

export const bookingService = {
  /**
   * Get all bookings for a customer
   */
  getCustomerBookings: async (
    customerId: string, 
    status?: BookingStatus
  ): Promise<Booking[]> => {
    let query = supabase
      .from('bookings')
      .select('*')
      .eq('customer_id', customerId)
      .order('created_at', { ascending: false });
    
    if (status) {
      query = query.eq('status', status);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  },

  /**
   * Get all bookings assigned to a mover
   */
  getMoverBookings: async (
    moverId: string,
    statuses?: BookingStatus[]
  ): Promise<Booking[]> => {
    let query = supabase
      .from('bookings')
      .select('*')
      .eq('mover_id', moverId)
      .order('scheduled_date', { ascending: true });
    
    if (statuses && statuses.length > 0) {
      query = query.in('status', statuses);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  },

  /**
   * Get a single booking by ID
   */
  getById: async (id: string): Promise<Booking | null> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }
    return data;
  },

  /**
   * Get booking by booking number
   */
  getByBookingNumber: async (bookingNumber: string): Promise<Booking | null> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('booking_number', bookingNumber)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }
    return data;
  },

  /**
   * Create a new booking
   */
  create: async (input: CreateBookingInput): Promise<Booking> => {
    const { data, error } = await supabase
      .from('bookings')
      .insert({
        customer_id: input.customer_id,
        pickup_address: input.pickup_address,
        pickup_location: `POINT(${input.pickup_longitude} ${input.pickup_latitude})`,
        dropoff_address: input.dropoff_address,
        dropoff_location: `POINT(${input.dropoff_longitude} ${input.dropoff_latitude})`,
        scheduled_date: input.scheduled_date,
        scheduled_time_start: input.scheduled_time_start,
        property_size: input.property_size,
        estimated_price: input.estimated_price,
        inventory: input.inventory || {},
        additional_services: input.additional_services || [],
        special_instructions: input.special_instructions,
        has_fragile_items: input.has_fragile_items || false,
        requires_insurance: input.requires_insurance || false,
        status: 'pending' as BookingStatus,
        booking_number: '' // Auto-generated by trigger
      })
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Update booking
   */
  update: async (id: string, updates: UpdateBookingInput): Promise<Booking> => {
    const { data, error } = await supabase
      .from('bookings')
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Assign mover to booking
   */
  assignMover: async (bookingId: string, moverId: string, quotedPrice: number): Promise<Booking> => {
    const { data, error } = await supabase
      .from('bookings')
      .update({
        mover_id: moverId,
        quoted_price: quotedPrice,
        status: 'accepted' as BookingStatus,
        accepted_at: new Date().toISOString()
      })
      .eq('id', bookingId)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Update booking status
   */
  updateStatus: async (bookingId: string, status: BookingStatus): Promise<Booking> => {
    const updates: any = { status };
    
    // Add timestamps based on status
    if (status === 'in_progress') {
      updates.started_at = new Date().toISOString();
    } else if (status === 'completed') {
      updates.completed_at = new Date().toISOString();
    } else if (status.startsWith('cancelled')) {
      updates.cancelled_at = new Date().toISOString();
    }
    
    const { data, error } = await supabase
      .from('bookings')
      .update(updates)
      .eq('id', bookingId)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Cancel booking
   */
  cancel: async (
    bookingId: string, 
    cancelledBy: 'customer' | 'mover' | 'system',
    reason?: string
  ): Promise<Booking> => {
    const status: BookingStatus = 
      cancelledBy === 'customer' ? 'cancelled_customer' :
      cancelledBy === 'mover' ? 'cancelled_mover' : 'cancelled_system';
    
    const { data, error } = await supabase
      .from('bookings')
      .update({
        status,
        cancelled_at: new Date().toISOString(),
        cancellation_reason: reason
      })
      .eq('id', bookingId)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Get active bookings (for dashboard)
   */
  getActiveBookings: async (customerId: string): Promise<Booking[]> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('customer_id', customerId)
      .in('status', ['pending', 'accepted', 'mover_en_route', 'in_progress'])
      .order('scheduled_date', { ascending: true });
    
    if (error) throw error;
    return data || [];
  },

  /**
   * Get booking history (completed/cancelled)
   */
  getBookingHistory: async (customerId: string): Promise<Booking[]> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('customer_id', customerId)
      .in('status', ['completed', 'cancelled_customer', 'cancelled_mover', 'cancelled_system'])
      .order('created_at', { ascending: false })
      .limit(20);
    
    if (error) throw error;
    return data || [];
  }
};
