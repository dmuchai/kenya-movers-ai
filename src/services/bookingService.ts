/**
 * Booking Service - Type-safe database operations for bookings
 */

import { supabase } from '@/integrations/supabase/client';
import type { Database } from '@/integrations/supabase/types';

// Type aliases from Supabase generated types
type Booking = Database['public']['Tables']['bookings']['Row'];
type BookingInsert = Database['public']['Tables']['bookings']['Insert'];
type BookingUpdate = Database['public']['Tables']['bookings']['Update'];
type BookingStatus = Database['public']['Enums']['booking_status_enum'];

// Type for creating a new booking (simplified from Insert type)
export interface CreateBookingInput {
  customer_id: string;
  pickup_address: string;
  pickup_latitude: number;
  pickup_longitude: number;
  dropoff_address: string;
  dropoff_latitude: number;
  dropoff_longitude: number;
  scheduled_date: string;
  scheduled_time_start: string;
  scheduled_time_end?: string;
  property_size: string;
  estimated_price: number;
  special_instructions?: string;
  customer_notes?: string;
  quote_id?: string;
  inventory?: any;
  additional_services?: string[];
  has_fragile_items?: boolean;
  requires_insurance?: boolean;
}

// Type for updating a booking (simplified from Update type)
export interface UpdateBookingInput {
  status?: BookingStatus;
  mover_id?: string;
  quoted_price?: number;
  final_price?: number;
  mover_notes?: string;
  admin_notes?: string;
}

export const bookingService = {
  /**
   * Get all bookings for a customer
   */
  getCustomerBookings: async (
    customerId: string, 
    status?: BookingStatus
  ): Promise<Booking[]> => {
    let query = supabase
      .from('bookings')
      .select('*')
      .eq('customer_id', customerId)
      .order('created_at', { ascending: false });
    
    if (status) {
      query = query.eq('status', status);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  },

  /**
   * Get all bookings assigned to a mover
   */
  getMoverBookings: async (
    moverId: string,
    statuses?: BookingStatus[]
  ): Promise<Booking[]> => {
    let query = supabase
      .from('bookings')
      .select('*')
      .eq('mover_id', moverId)
      .order('scheduled_date', { ascending: true });
    
    if (statuses && statuses.length > 0) {
      query = query.in('status', statuses);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  },

  /**
   * Get a single booking by ID
   */
  getById: async (id: string): Promise<Booking | null> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }
    return data;
  },

  /**
   * Get booking by booking number
   */
  getByBookingNumber: async (bookingNumber: string): Promise<Booking | null> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('booking_number', bookingNumber)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }
    return data;
  },

  /**
   * Create a new booking
   */
  create: async (input: CreateBookingInput): Promise<Booking> => {
    const { data, error } = await supabase
      .from('bookings')
      .insert({
        customer_id: input.customer_id,
        pickup_address: input.pickup_address,
        pickup_location: `POINT(${input.pickup_longitude} ${input.pickup_latitude})`,
        dropoff_address: input.dropoff_address,
        dropoff_location: `POINT(${input.dropoff_longitude} ${input.dropoff_latitude})`,
        scheduled_date: input.scheduled_date,
        scheduled_time_start: input.scheduled_time_start,
        scheduled_time_end: input.scheduled_time_end,
        property_size: input.property_size,
        estimated_price: input.estimated_price,
        inventory: input.inventory || {},
        additional_services: input.additional_services || [],
        special_instructions: input.special_instructions,
        customer_notes: input.customer_notes,
        quote_id: input.quote_id,
        has_fragile_items: input.has_fragile_items || false,
        requires_insurance: input.requires_insurance || false,
        status: 'pending' as BookingStatus,
        booking_number: '' // Auto-generated by trigger
      })
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Update booking
   */
  update: async (id: string, updates: UpdateBookingInput): Promise<Booking> => {
    const { data, error } = await supabase
      .from('bookings')
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Assign mover to booking
   * Validates booking state, mover existence, and quoted price before assignment
   */
  assignMover: async (bookingId: string, moverId: string, quotedPrice: number): Promise<Booking> => {
    // Configuration: Maximum reasonable price for validation
    const MAX_REASONABLE_PRICE = 500000; // 500,000 KES (adjust based on business requirements)
    const MAX_PRICE_DEVIATION_MULTIPLIER = 3; // Quoted price can be max 3x estimated price
    
    // Step 1: Fetch existing booking and validate it exists
    const { data: existingBooking, error: fetchError } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', bookingId)
      .single();
    
    if (fetchError) {
      throw new Error(`Failed to fetch booking: ${fetchError.message}`);
    }
    
    if (!existingBooking) {
      throw new Error(`Booking not found with id: ${bookingId}`);
    }
    
    // Step 2: Validate booking status - only allow assignment if booking is in valid pre-assignment state
    const allowedStatuses: BookingStatus[] = ['pending'];
    
    if (!allowedStatuses.includes(existingBooking.status as BookingStatus)) {
      throw new Error(
        `Cannot assign mover to booking with status '${existingBooking.status}'. ` +
        `Booking must be in one of these states: ${allowedStatuses.join(', ')}`
      );
    }
    
    // Step 3: Validate quoted price is positive
    if (quotedPrice <= 0) {
      throw new Error(`Invalid quoted price: ${quotedPrice}. Price must be greater than 0.`);
    }
    
    // Step 4: Validate quoted price is within reasonable bounds
    if (quotedPrice > MAX_REASONABLE_PRICE) {
      throw new Error(
        `Quoted price ${quotedPrice} KES exceeds maximum reasonable price of ${MAX_REASONABLE_PRICE} KES. ` +
        `Please review the quote or contact administrator.`
      );
    }
    
    // Step 5: Compare quoted price against estimated price (allow reasonable deviation)
    if (existingBooking.estimated_price) {
      const maxAllowedQuote = existingBooking.estimated_price * MAX_PRICE_DEVIATION_MULTIPLIER;
      
      if (quotedPrice > maxAllowedQuote) {
        throw new Error(
          `Quoted price ${quotedPrice} KES is too high compared to estimated price ${existingBooking.estimated_price} KES. ` +
          `Maximum allowed is ${maxAllowedQuote} KES (${MAX_PRICE_DEVIATION_MULTIPLIER}x estimate). ` +
          `Please provide a more reasonable quote.`
        );
      }
    }
    
    // Step 6: Validate mover exists and has mover role
    const { data: mover, error: moverError } = await supabase
      .from('movers')
      .select('id, user_id, verification_status')
      .eq('id', moverId)
      .single();
    
    if (moverError || !mover) {
      throw new Error(`Mover not found with id: ${moverId}. Please ensure the mover exists and is registered.`);
    }
    
    // Optional: Check mover verification status
    if (mover.verification_status !== 'verified') {
      throw new Error(
        `Mover ${moverId} is not verified (status: ${mover.verification_status}). ` +
        `Only verified movers can accept bookings.`
      );
    }
    
    // Step 7: Perform the update after all validations pass
    const { data, error } = await supabase
      .from('bookings')
      .update({
        mover_id: moverId,
        quoted_price: quotedPrice,
        status: 'accepted' as BookingStatus,
        accepted_at: new Date().toISOString()
      })
      .eq('id', bookingId)
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to assign mover to booking: ${error.message}`);
    }
    
    return data;
  },

  updateStatus: async (bookingId: string, status: BookingStatus): Promise<Booking> => {
    const updates: BookingUpdate = { status };
    
    // Add timestamps based on status
    if (status === 'in_progress') {
      updates.started_at = new Date().toISOString();
    } else if (status === 'completed') {
      updates.completed_at = new Date().toISOString();
    } else if (status.startsWith('cancelled')) {
      updates.cancelled_at = new Date().toISOString();
    }
    
    // Validate state transition
    const booking = await bookingService.getById(bookingId);
    if (!booking) {
      throw new Error(`Booking ${bookingId} not found`);
    }

    const terminalStates: BookingStatus[] = [
      'completed',
      'cancelled_customer',
      'cancelled_mover',
      'cancelled_system'
    ];
    if (terminalStates.includes(booking.status)) {
      throw new Error(`Cannot change status from terminal state: ${booking.status}`);
    }
    
    const { data, error } = await supabase
      .from('bookings')
      .update(updates)
      .eq('id', bookingId)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  /**
   * Cancel booking
   */
  cancel: async (
    bookingId: string, 
    cancelledBy: 'customer' | 'mover' | 'system',
    reason?: string
  ): Promise<Booking> => {
    const status: BookingStatus = 
      cancelledBy === 'customer' ? 'cancelled_customer' :
      cancelledBy === 'mover' ? 'cancelled_mover' : 'cancelled_system';
    
    const { data, error } = await supabase
      .from('bookings')
      .update({
        status,
        cancelled_at: new Date().toISOString(),
        cancellation_reason: reason
      })
      .eq('id', bookingId)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  /**
   * Get active bookings (for dashboard)
   */
  getActiveBookings: async (customerId: string): Promise<Booking[]> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('customer_id', customerId)
      .in('status', ['pending', 'accepted', 'mover_en_route', 'in_progress'])
      .order('scheduled_date', { ascending: true });
    
    if (error) throw error;
    return data || [];
  },

  /**
   * Get booking history (completed/cancelled)
   */
  getBookingHistory: async (customerId: string): Promise<Booking[]> => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('customer_id', customerId)
      .in('status', ['completed', 'cancelled_customer', 'cancelled_mover', 'cancelled_system'])
      .order('created_at', { ascending: false })
      .limit(20);
    
    if (error) throw error;
    return data || [];
  }
};
